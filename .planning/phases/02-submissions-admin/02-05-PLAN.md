---
phase: 02-submissions-admin
plan: 05
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - package.json
  - src/app/(admin)/pending/page.tsx
  - src/app/(admin)/pending/actions.ts
  - src/components/admin/pending-table.tsx
  - src/components/admin/columns-pending.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can view list of pending submissions in a sortable table"
    - "Admin can approve a submission, which creates a new approved listing"
    - "Admin can reject a submission with optional notes"
    - "Approved/rejected submissions are removed from pending queue"
    - "Duplicate flags are visible to admin in the pending queue"
  artifacts:
    - path: "src/app/(admin)/pending/page.tsx"
      provides: "Server component fetching pending submissions"
      contains: "PendingTable"
    - path: "src/app/(admin)/pending/actions.ts"
      provides: "Server Actions for approve/reject moderation"
      exports: ["approveSubmission", "rejectSubmission"]
    - path: "src/components/admin/pending-table.tsx"
      provides: "TanStack Table for pending submissions"
      contains: "useReactTable"
  key_links:
    - from: "src/app/(admin)/pending/actions.ts"
      to: "src/lib/db/schema.ts"
      via: "Insert into listings on approve, update submissions status"
      pattern: "db\\.insert.*listings.*db\\.update.*submissions"
    - from: "src/app/(admin)/pending/page.tsx"
      to: "src/lib/db/schema.ts"
      via: "Select pending submissions"
      pattern: "db\\.select.*submissions.*pending"
---

<objective>
Build the admin moderation queue where Collab staff can view, approve, or reject pending submissions using a TanStack Table data table.

Purpose: This is the core admin feature of Phase 2. Pending submissions need to be reviewed before appearing in the directory. The approve action converts a submission into an approved listing.

Output: /admin/pending page with data table, approve/reject server actions, duplicate flag visibility.
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-submissions-admin/02-RESEARCH.md
@.planning/phases/02-submissions-admin/02-01-SUMMARY.md
@.planning/phases/02-submissions-admin/02-02-SUMMARY.md

Key dependencies:
- submissions table in src/lib/db/schema.ts (from 02-01)
- Admin layout with sidebar at src/app/(admin)/layout.tsx (from 02-02)
- UI components: Table, Badge, Button, Dialog (from 02-01)
- Clerk auth already protecting /admin routes (from 02-02)

Research patterns:
- TanStack Table v8 with shadcn/ui table primitives
- Server Actions for approve/reject (not API routes)
- Show loading state, wait for server confirmation (no optimistic updates for admin)
- Approval copies submission data into listings table with status='approved'
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install TanStack Table and create moderation Server Actions</name>
  <files>
    package.json
    src/app/(admin)/pending/actions.ts
  </files>
  <action>
1. Install TanStack Table:
```bash
npm install @tanstack/react-table
```

2. Create `src/app/(admin)/pending/actions.ts` — Server Actions for moderation:

```typescript
'use server'

import { db } from '@/lib/db'
import { submissions, listings } from '@/lib/db/schema'
import { eq } from 'drizzle-orm'
import { revalidatePath } from 'next/cache'
import { auth } from '@clerk/nextjs/server'

export async function approveSubmission(submissionId: string) {
  const { userId } = await auth()
  if (!userId) throw new Error('Unauthorized')

  // 1. Fetch the submission
  const [submission] = await db
    .select()
    .from(submissions)
    .where(eq(submissions.id, submissionId))
    .limit(1)

  if (!submission) {
    return { error: 'Submission not found' }
  }

  if (submission.status !== 'pending') {
    return { error: 'Submission has already been reviewed' }
  }

  // 2. Create a new listing from submission data
  await db.insert(listings).values({
    name: submission.name,
    description: submission.description,
    role: submission.role,
    specialties: submission.specialties,
    address: submission.formattedAddress || submission.address,
    phone: submission.phone,
    email: submission.email,
    website: submission.website,
    location: submission.location,
    status: 'approved',
  })

  // 3. Update submission status to approved
  await db
    .update(submissions)
    .set({
      status: 'approved',
      reviewedAt: new Date(),
      reviewedBy: userId,
      updatedAt: new Date(),
    })
    .where(eq(submissions.id, submissionId))

  revalidatePath('/admin/pending')
  revalidatePath('/admin')
  revalidatePath('/')

  return { success: true }
}

export async function rejectSubmission(submissionId: string, notes?: string) {
  const { userId } = await auth()
  if (!userId) throw new Error('Unauthorized')

  const [submission] = await db
    .select()
    .from(submissions)
    .where(eq(submissions.id, submissionId))
    .limit(1)

  if (!submission) {
    return { error: 'Submission not found' }
  }

  if (submission.status !== 'pending') {
    return { error: 'Submission has already been reviewed' }
  }

  await db
    .update(submissions)
    .set({
      status: 'rejected',
      adminNotes: notes || null,
      reviewedAt: new Date(),
      reviewedBy: userId,
      updatedAt: new Date(),
    })
    .where(eq(submissions.id, submissionId))

  revalidatePath('/admin/pending')
  revalidatePath('/admin')

  return { success: true }
}
```

Key design decisions:
- Auth check in every server action (defense in depth, middleware protects route but action validates too)
- Approve copies submission data into listings table with status='approved'
- Reject updates submission status and optionally adds admin notes
- revalidatePath on pending queue, admin dashboard, and public homepage
- No optimistic updates — wait for server confirmation per research guidance
- Use plain return objects (not class instances) to avoid Server Action serialization issues
  </action>
  <verify>
Run `npx tsc --noEmit`. Verify @tanstack/react-table in package.json. Verify actions.ts exports approveSubmission and rejectSubmission.
  </verify>
  <done>
TanStack Table installed. Server Actions for approve (copies to listings) and reject (updates status + notes) with auth checks and path revalidation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pending submissions table page with TanStack Table</name>
  <files>
    src/app/(admin)/pending/page.tsx
    src/components/admin/pending-table.tsx
    src/components/admin/columns-pending.tsx
  </files>
  <action>
1. Create `src/components/admin/columns-pending.tsx` — Column definitions (client component):

```typescript
'use client'

import { ColumnDef } from '@tanstack/react-table'
import { Badge } from '@/components/ui/badge'

// Plain serializable type for submissions passed from server to client
export type PendingSubmission = {
  id: string
  name: string
  email: string
  role: string
  address: string
  submittedAt: string // ISO string (serializable)
  duplicateOf: string | null
  similarityScore: string | null
}

export const columns: ColumnDef<PendingSubmission>[] = [
  {
    accessorKey: 'name',
    header: 'Name',
    cell: ({ row }) => {
      const hasDuplicate = row.original.duplicateOf
      return (
        <div>
          <span className="font-medium text-slate-50">{row.getValue('name')}</span>
          {hasDuplicate && (
            <Badge variant="warning" className="ml-2">
              Possible Duplicate ({Math.round(parseFloat(row.original.similarityScore || '0') * 100)}%)
            </Badge>
          )}
        </div>
      )
    },
  },
  {
    accessorKey: 'email',
    header: 'Email',
  },
  {
    accessorKey: 'role',
    header: 'Category',
    cell: ({ row }) => (
      <Badge variant="default">{row.getValue('role')}</Badge>
    ),
  },
  {
    accessorKey: 'address',
    header: 'Address',
    cell: ({ row }) => (
      <span className="max-w-[200px] truncate block">{row.getValue('address')}</span>
    ),
  },
  {
    accessorKey: 'submittedAt',
    header: 'Submitted',
    cell: ({ row }) => {
      const date = new Date(row.getValue('submittedAt'))
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })
    },
  },
  {
    id: 'actions',
    header: 'Actions',
    // Actions cell is defined in the table component where it has access to action handlers
  },
]
```

2. Create `src/components/admin/pending-table.tsx` — Client component with TanStack Table:

```typescript
'use client'

import { useState } from 'react'
import {
  flexRender,
  getCoreRowModel,
  useReactTable,
  getSortedRowModel,
  SortingState,
} from '@tanstack/react-table'
import {
  Table, TableBody, TableCell, TableHead, TableHeader, TableRow,
} from '@/components/ui/table'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogClose } from '@/components/ui/dialog'
import { Textarea } from '@/components/ui/textarea'
import { approveSubmission, rejectSubmission } from '@/app/(admin)/pending/actions'
import type { PendingSubmission } from './columns-pending'

export function PendingTable({ data }: { data: PendingSubmission[] }) {
  const [sorting, setSorting] = useState<SortingState>([])
  const [actionLoading, setActionLoading] = useState<string | null>(null)
  const [rejectId, setRejectId] = useState<string | null>(null)
  const [rejectNotes, setRejectNotes] = useState('')

  async function handleApprove(id: string) {
    setActionLoading(id)
    try {
      const result = await approveSubmission(id)
      if (result.error) {
        alert(result.error)
      }
    } catch {
      alert('Failed to approve submission')
    }
    setActionLoading(null)
  }

  async function handleReject() {
    if (!rejectId) return
    setActionLoading(rejectId)
    try {
      const result = await rejectSubmission(rejectId, rejectNotes)
      if (result.error) {
        alert(result.error)
      }
    } catch {
      alert('Failed to reject submission')
    }
    setActionLoading(null)
    setRejectId(null)
    setRejectNotes('')
  }

  // Build columns with actions (need closure over handlers)
  const columnsWithActions = [
    {
      accessorKey: 'name',
      header: 'Name',
      cell: ({ row }) => {
        const hasDuplicate = row.original.duplicateOf
        return (
          <div>
            <span className="font-medium text-slate-50">{row.getValue('name')}</span>
            {hasDuplicate && (
              <span className="ml-2 inline-flex items-center rounded-full bg-yellow-900 px-2 py-0.5 text-xs font-semibold text-yellow-200">
                Possible Duplicate ({Math.round(parseFloat(row.original.similarityScore || '0') * 100)}%)
              </span>
            )}
          </div>
        )
      },
    },
    { accessorKey: 'email', header: 'Email' },
    {
      accessorKey: 'role',
      header: 'Category',
      cell: ({ row }) => (
        <span className="inline-flex items-center rounded-full bg-slate-700 px-2.5 py-0.5 text-xs font-semibold text-slate-200">
          {row.getValue('role')}
        </span>
      ),
    },
    {
      accessorKey: 'address',
      header: 'Address',
      cell: ({ row }) => (
        <span className="max-w-[200px] truncate block text-slate-300">{row.getValue('address')}</span>
      ),
    },
    {
      accessorKey: 'submittedAt',
      header: 'Submitted',
      cell: ({ row }) => {
        const date = new Date(row.getValue('submittedAt'))
        return <span className="text-slate-400">{date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</span>
      },
    },
    {
      id: 'actions',
      header: 'Actions',
      cell: ({ row }) => {
        const id = row.original.id
        const loading = actionLoading === id
        return (
          <div className="flex gap-2">
            <button
              onClick={() => handleApprove(id)}
              disabled={loading}
              className="rounded-md bg-green-700 px-3 py-1.5 text-xs font-medium text-green-50 hover:bg-green-600 disabled:opacity-50 transition-colors"
            >
              {loading ? 'Processing...' : 'Approve'}
            </button>
            <button
              onClick={() => setRejectId(id)}
              disabled={loading}
              className="rounded-md bg-red-700 px-3 py-1.5 text-xs font-medium text-red-50 hover:bg-red-600 disabled:opacity-50 transition-colors"
            >
              Reject
            </button>
          </div>
        )
      },
    },
  ]

  const table = useReactTable({
    data,
    columns: columnsWithActions,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    onSortingChange: setSorting,
    state: { sorting },
  })

  return (
    <>
      <div className="rounded-md border border-slate-800">
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => (
                  <TableHead key={header.id}>
                    {header.isPlaceholder ? null : flexRender(header.column.columnDef.header, header.getContext())}
                  </TableHead>
                ))}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow key={row.id}>
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell colSpan={columnsWithActions.length} className="h-24 text-center text-slate-400">
                  No pending submissions.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>

      {/* Reject confirmation dialog */}
      {rejectId && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
          <div className="bg-slate-900 border border-slate-700 rounded-lg p-6 shadow-xl max-w-md w-full mx-4">
            <h3 className="text-lg font-semibold text-slate-50 mb-2">Reject Submission</h3>
            <p className="text-sm text-slate-400 mb-4">
              Are you sure you want to reject this submission? You can add optional notes.
            </p>
            <textarea
              value={rejectNotes}
              onChange={(e) => setRejectNotes(e.target.value)}
              placeholder="Reason for rejection (optional)"
              className="w-full min-h-[80px] rounded-md border border-slate-700 bg-slate-800 px-3 py-2 text-sm text-slate-50 placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-slate-400 mb-4"
            />
            <div className="flex gap-2 justify-end">
              <button
                onClick={() => { setRejectId(null); setRejectNotes('') }}
                className="rounded-md border border-slate-700 px-4 py-2 text-sm text-slate-50 hover:bg-slate-800 transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={handleReject}
                disabled={actionLoading === rejectId}
                className="rounded-md bg-red-600 px-4 py-2 text-sm font-medium text-white hover:bg-red-700 disabled:opacity-50 transition-colors"
              >
                {actionLoading === rejectId ? 'Rejecting...' : 'Reject'}
              </button>
            </div>
          </div>
        </div>
      )}
    </>
  )
}
```

Note: Use inline styles for badge/button in columns instead of importing Badge/Button components to keep column definitions simpler and avoid the complexity of passing components through TanStack Table's render pipeline. The Dialog for reject is implemented as a simple modal overlay (matching the pattern from 02-01 dialog component).

3. Create `src/app/(admin)/pending/page.tsx` — Server component that fetches pending submissions:

```typescript
import { db } from '@/lib/db'
import { submissions } from '@/lib/db/schema'
import { eq, desc } from 'drizzle-orm'
import { PendingTable } from '@/components/admin/pending-table'

export default async function PendingSubmissionsPage() {
  const pending = await db
    .select({
      id: submissions.id,
      name: submissions.name,
      email: submissions.email,
      role: submissions.role,
      address: submissions.formattedAddress,
      submittedAt: submissions.submittedAt,
      duplicateOf: submissions.duplicateOf,
      similarityScore: submissions.similarityScore,
    })
    .from(submissions)
    .where(eq(submissions.status, 'pending'))
    .orderBy(desc(submissions.submittedAt))

  // Convert dates to ISO strings for serialization
  const serialized = pending.map(s => ({
    ...s,
    address: s.address || '',
    submittedAt: s.submittedAt.toISOString(),
  }))

  return (
    <div>
      <div className="flex items-center justify-between mb-8">
        <div>
          <h1 className="text-2xl font-bold text-slate-50 font-heading">
            Pending Submissions
          </h1>
          <p className="text-sm text-slate-400 mt-1">
            {pending.length} submission{pending.length !== 1 ? 's' : ''} awaiting review
          </p>
        </div>
      </div>
      <PendingTable data={serialized} />
    </div>
  )
}
```

IMPORTANT: Serialize Date objects to ISO strings before passing to client component (Server Action serialization pitfall from research). Only select the fields needed for the table display to minimize data transfer.
  </action>
  <verify>
Run `npx tsc --noEmit`. Verify all files exist. Check that PendingTable uses useReactTable from @tanstack/react-table. Verify approve action inserts into listings table. Verify reject action updates submission status.
  </verify>
  <done>
Pending submissions page shows TanStack Table with name, email, category, address, submitted date, and duplicate flags. Approve button creates listing and marks submission as approved. Reject button opens dialog for optional notes and marks as rejected. Empty state shown when no pending submissions.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. /admin/pending page renders table with column headers
3. Approve action creates new listing row and updates submission status
4. Reject action opens dialog, updates submission status with optional notes
5. Duplicate flags visible as yellow badges in name column
6. revalidatePath called after each action to refresh data
7. Dates properly serialized as ISO strings for client component
</verification>

<success_criteria>
- Admin can view all pending submissions in a sortable table at /admin/pending
- Clicking Approve creates a new listing and removes submission from queue
- Clicking Reject shows dialog for notes and removes submission from queue
- Duplicate flags show yellow badge with similarity percentage
- Empty state message when no pending submissions
- Loading states on action buttons prevent double-clicks
</success_criteria>

<output>
After completion, create `.planning/phases/02-submissions-admin/02-05-SUMMARY.md`
</output>

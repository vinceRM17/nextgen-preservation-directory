---
phase: 02-submissions-admin
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/geocoding/client.ts
  - src/lib/geocoding/validation.ts
  - src/lib/duplicate-detection/similarity.ts
  - .env.example
autonomous: true
user_setup:
  - service: mapbox
    why: "Address geocoding and Louisville bounds validation"
    env_vars:
      - name: MAPBOX_ACCESS_TOKEN
        source: "Mapbox Account (mapbox.com) -> Tokens page -> Default public token or create new"
    dashboard_config:
      - task: "Create free Mapbox account"
        location: "mapbox.com -> Sign up (free tier: 100K geocoding requests/month)"

must_haves:
  truths:
    - "Addresses can be geocoded to coordinates via Mapbox API"
    - "Geocoded coordinates are validated to be within Louisville Metro bounds"
    - "Similar existing listings can be found by name using pg_trgm similarity"
    - "Duplicate detection returns similarity scores for admin review"
  artifacts:
    - path: "src/lib/geocoding/client.ts"
      provides: "Mapbox geocoding API wrapper"
      exports: ["geocodeAddress"]
    - path: "src/lib/geocoding/validation.ts"
      provides: "Louisville bounds checking"
      exports: ["isWithinLouisville", "LOUISVILLE_BOUNDS"]
    - path: "src/lib/duplicate-detection/similarity.ts"
      provides: "pg_trgm similarity queries via Drizzle"
      exports: ["findSimilarListings"]
  key_links:
    - from: "src/lib/geocoding/client.ts"
      to: "Mapbox Geocoding API"
      via: "HTTP fetch to api.mapbox.com"
      pattern: "api\\.mapbox\\.com.*geocode"
    - from: "src/lib/duplicate-detection/similarity.ts"
      to: "src/lib/db/schema.ts"
      via: "SQL similarity() queries against listings table"
      pattern: "similarity.*listings"
---

<objective>
Create the geocoding client (Mapbox API) for address validation and the duplicate detection utility (pg_trgm) for flagging similar submissions.

Purpose: The public submission form (02-04) needs geocoding to validate addresses and duplicate detection to flag potential duplicates before saving. Building these as isolated utilities enables clean integration and testability.

Output: Geocoding client with Louisville bounds validation, duplicate detection with configurable similarity threshold.
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-submissions-admin/02-RESEARCH.md

Key context:
- pg_trgm extension already enabled (migration 0001 from Phase 1)
- Trigram GIN indexes created in plan 02-01 (migration 0003)
- Drizzle ORM with raw SQL via sql`` template tag
- PostGIS geometry stored as geometry(Point, 4326)
- Database client in src/lib/db/index.ts exports `db` and all schema
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Mapbox geocoding client with Louisville bounds validation</name>
  <files>
    src/lib/geocoding/client.ts
    src/lib/geocoding/validation.ts
    .env.example
  </files>
  <action>
1. Create `src/lib/geocoding/validation.ts` with Louisville Metro bounding box:

```typescript
// Louisville Metro approximate bounding box (Jefferson County + surrounding)
export const LOUISVILLE_BOUNDS = {
  minLon: -85.966,
  minLat: 37.991,
  maxLon: -85.414,
  maxLat: 38.362,
} as const

// Louisville center for proximity bias in geocoding
export const LOUISVILLE_CENTER = {
  lon: -85.7585,
  lat: 38.2527,
} as const

export function isWithinLouisville(lon: number, lat: number): boolean {
  return (
    lon >= LOUISVILLE_BOUNDS.minLon &&
    lon <= LOUISVILLE_BOUNDS.maxLon &&
    lat >= LOUISVILLE_BOUNDS.minLat &&
    lat <= LOUISVILLE_BOUNDS.maxLat
  )
}
```

2. Create `src/lib/geocoding/client.ts` with Mapbox forward geocoding:

```typescript
import { isWithinLouisville, LOUISVILLE_CENTER } from './validation'

export type GeocodeResult = {
  success: true
  data: {
    coordinates: { x: number; y: number } // lon, lat (x=lon, y=lat for PostGIS)
    formattedAddress: string
  }
} | {
  success: false
  error: string
}

export async function geocodeAddress(address: string): Promise<GeocodeResult> {
  const token = process.env.MAPBOX_ACCESS_TOKEN

  if (!token) {
    console.error('MAPBOX_ACCESS_TOKEN not configured')
    return {
      success: false,
      error: 'Geocoding service not configured. Please contact admin.',
    }
  }

  try {
    const encodedAddress = encodeURIComponent(address)
    const url = `https://api.mapbox.com/search/geocode/v6/forward?q=${encodedAddress}&proximity=${LOUISVILLE_CENTER.lon},${LOUISVILLE_CENTER.lat}&limit=1&country=us&access_token=${token}`

    const response = await fetch(url, {
      next: { revalidate: 3600 }, // Cache geocoding results for 1 hour
    })

    if (!response.ok) {
      if (response.status === 429) {
        return { success: false, error: 'Geocoding rate limit exceeded. Please try again later.' }
      }
      return { success: false, error: 'Geocoding service unavailable. Please try again.' }
    }

    const data = await response.json()

    if (!data.features || data.features.length === 0) {
      return {
        success: false,
        error: 'Address not found. Please check the address and try again.',
      }
    }

    const feature = data.features[0]
    const [lon, lat] = feature.geometry.coordinates

    // Validate within Louisville Metro bounds
    if (!isWithinLouisville(lon, lat)) {
      return {
        success: false,
        error: 'Address must be within the Louisville Metro area.',
      }
    }

    const formattedAddress =
      feature.properties?.full_address ||
      feature.properties?.name ||
      address

    return {
      success: true,
      data: {
        coordinates: { x: lon, y: lat },
        formattedAddress,
      },
    }
  } catch (error) {
    console.error('Geocoding error:', error)
    return {
      success: false,
      error: 'Geocoding failed. Please try again.',
    }
  }
}
```

Key design decisions:
- Use Mapbox v6 geocoding API (latest as of 2026)
- Proximity bias toward Louisville center for better local results
- Country filter to US only
- Cache results for 1 hour using Next.js fetch cache
- Return discriminated union (success: true/false) for clean error handling
- Coordinates returned as {x: lon, y: lat} matching PostGIS POINT(lon lat) convention

3. Update `.env.example` to add MAPBOX_ACCESS_TOKEN entry (append to existing file, don't overwrite).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles. Verify both files exist. Verify .env.example has MAPBOX_ACCESS_TOKEN.
  </verify>
  <done>
Geocoding client wraps Mapbox v6 API with Louisville bounds validation. Returns discriminated union result. Handles rate limits, missing tokens, and invalid addresses gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pg_trgm duplicate detection utility</name>
  <files>
    src/lib/duplicate-detection/similarity.ts
  </files>
  <action>
Create `src/lib/duplicate-detection/similarity.ts`:

```typescript
import { sql } from 'drizzle-orm'
import { db } from '@/lib/db'
import { listings } from '@/lib/db/schema'

const DEFAULT_THRESHOLD = 0.4 // 40% similarity — catches "Louisville Masonry" vs "Louisville Masonry Co"

export type SimilarListing = {
  id: string
  name: string
  role: string
  similarity: number
}

/**
 * Find existing approved listings similar to the given name.
 * Uses PostgreSQL pg_trgm extension for trigram-based fuzzy matching.
 *
 * @param name - The name to check for duplicates
 * @param threshold - Minimum similarity score (0-1). Default: 0.4
 * @returns Array of similar listings with similarity scores, ordered by similarity desc
 */
export async function findSimilarListings({
  name,
  threshold = DEFAULT_THRESHOLD,
}: {
  name: string
  threshold?: number
}): Promise<SimilarListing[]> {
  try {
    const result = await db.execute<{
      id: string
      name: string
      role: string
      name_similarity: string
    }>(sql`
      SELECT
        id,
        name,
        role,
        similarity(name, ${name}) as name_similarity
      FROM listings
      WHERE
        status = 'approved'
        AND similarity(name, ${name}) > ${threshold}
      ORDER BY name_similarity DESC
      LIMIT 5
    `)

    return result.rows.map(row => ({
      id: row.id,
      name: row.name,
      role: row.role,
      similarity: parseFloat(row.name_similarity),
    }))
  } catch (error) {
    console.error('Duplicate detection error:', error)
    // Don't block submission on duplicate check failure
    return []
  }
}

/**
 * Check if a submission is a likely duplicate.
 * Returns the most similar listing if similarity > high threshold.
 */
export async function checkForDuplicate(name: string): Promise<SimilarListing | null> {
  const similar = await findSimilarListings({ name, threshold: 0.7 })
  return similar.length > 0 ? similar[0] : null
}
```

Key design decisions:
- Default threshold 0.4 is intentionally low to catch more potential duplicates for admin review (admin makes final call)
- High threshold (0.7) for `checkForDuplicate` used to auto-flag likely duplicates
- Only search approved listings (not pending or rejected)
- Gracefully return empty array on error — never block submissions due to duplicate check failure
- Query uses raw SQL with Drizzle's sql`` template for pg_trgm functions
- Limit to 5 results to keep response fast
- Parse similarity score from string to number (PostgreSQL returns numeric as string in some drivers)
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles. Verify the file exports `findSimilarListings` and `checkForDuplicate`. Verify SQL uses `similarity()` function from pg_trgm.
  </verify>
  <done>
Duplicate detection utility queries listings table using pg_trgm similarity(). Returns similar listings with scores. Two functions: findSimilarListings (broad, for admin display) and checkForDuplicate (strict, for auto-flagging). Graceful error handling — never blocks submissions.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `src/lib/geocoding/client.ts` exports `geocodeAddress` returning `GeocodeResult`
3. `src/lib/geocoding/validation.ts` exports `isWithinLouisville` and `LOUISVILLE_BOUNDS`
4. `src/lib/duplicate-detection/similarity.ts` exports `findSimilarListings` and `checkForDuplicate`
5. `.env.example` includes `MAPBOX_ACCESS_TOKEN`
</verification>

<success_criteria>
- geocodeAddress() returns success with coordinates and formatted address for valid Louisville addresses
- geocodeAddress() returns error for addresses outside Louisville bounds
- findSimilarListings() returns array of similar listings with similarity scores
- checkForDuplicate() returns null when no high-similarity matches exist
- All functions handle errors gracefully without throwing
</success_criteria>

<output>
After completion, create `.planning/phases/02-submissions-admin/02-03-SUMMARY.md`
</output>
